Banning golfing languages has been an idea since the [creation of the site], back when "golfing language" meant the clunky, outdated mess that is [Golfscript] and the general-purpose-but-short languages [J] and [APL]. The general idea behind the ban is that verbose languages such as [Java] are unable to compete with languages specially designed for golfing, so, in order to level the playing field, various different measures (handicaps, bans, language-specific competitions etc.) have been suggested.

In general, I disagree with these measures. [Code Golf.SE] has a principle of "Answers don't compete with all other answers, they compete with other answers *in the same language*". For example, a Java submission is only ever trying to beat the other Java submissions, rather than the [Jelly] answers. This is a good compromise of a policy, and I personally prefer it much more than sites that only allow specific languages. However, it can also feel a bit cheap or hand-wavy.

The thing I most enjoy about golfing languages is that they force you to think in completely different ways to regular languages. Their vast builtin libraries completely trivialise trivial problems - as they should. People complain that having a builtin to do something (for example, a builtin to calcualte the dot product of two arrays) trivialises that task. That it isn't "real coding" to just copy-paste the `á¸‹` character instead of having to actually write your own method. However, I wholeheartedly believe that if a task can be trivialised in a golfing language, it's a trivial task in *any* language.

Golfing languages are interesting when the challenge is interesting. Generally speaking, the more interesting a challenge is, the more interesting the golfing language answer will be, because the approaches are going to be completely different. Using a golfing language allows you to abstract away a task until you can distil it into its core principles. And, often, this results in a trivial answer in a golfing language, because the core of the challenge is trivial, but this can only be realised through the level of abstraction available in golfing languages. For example, consider [this] Jelly answer to a challenge about the [Padovan sequence]. This sequence is similar to the Fibonacci sequence, and so most practical languages use this approach. However, this style of recursion is not always golfy in golfing languages, so it requires a fresh take and a new way to understand the task in order to create a competitive solution.

This is, in my opinion, the biggest argument for golfing languages. The obvious solution may not always be the shortest in every language, and by expanding the ways one can approach a problem (via expanding the builtins available), golfing languages are able to find more creative ways to answer. That's not to say that practical languages can't be interesting, but that the approaches in practical languages are limited by their builtin set.

---

[creation of the site]: https://codegolf.meta.stackexchange.com/q/286/66833
[Golfscript]: http://www.golfscript.com/golfscript/
[J]: https://www.jsoftware.com/#/
[APL]: https://aplwiki.com/wiki/
[Java]: https://www.java.com/en/
[Code Golf.SE]: 
[Jelly]: https://github.com/DennisMitchell/jelly
[this]: https://codegolf.stackexchange.com/a/182825/66833
[Padovan sequence]: https://en.wikipedia.org/wiki/Padovan_sequence
